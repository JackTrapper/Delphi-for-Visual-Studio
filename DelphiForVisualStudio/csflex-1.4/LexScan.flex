/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * C# Flex 1.4                                                             *
 * Copyright (C) 2004-2005  Jonathan Gilbert <logic@deltaq.org>            *
 * Derived from:                                                           *
 *                                                                         *
 *   JFlex 1.4                                                             *
 *   Copyright (C) 1998-2004  Gerwin Klein <lsf@jflex.de>                  *
 *   All rights reserved.                                                  *
 *                                                                         *
 * This program is free software; you can redistribute it and/or modify    *
 * it under the terms of the GNU General Public License. See the file      *
 * COPYRIGHT for more information.                                         *
 *                                                                         *
 * This program is distributed in the hope that it will be useful,         *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 * GNU General Public License for more details.                            *
 *                                                                         *
 * You should have received a copy of the GNU General Public License along *
 * with this program; if not, write to the Free Software Foundation, Inc., *
 * 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA                 *
 *                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

using System;
using System.Collections;
using System.IO;
using System.Text;

using java_cup.runtime;

namespace CSFlex
{

/**
 * The lexer of C# Flex.
 *
 * Generated by C# Flex, based on <a href="http://www.jflex.de/">JFlex</a>.
 *
 * @author Gerwin Klein
 * @author Jonathan Gilbert
 * @version CSFlex 1.4, $Revision: 2.6 $, $Date: 2004/04/12 10:07:47 $
 */
%%

%final
%public
%class LexScan
%implements sym, java_cup.runtime.Scanner
%function next_token

%type Symbol
%unicode

%column
%line

%eofclose

%state COMMENT, STATELIST, MACROS, REGEXPSTART
%state REGEXP, JAVA_CODE, STATES, STRING_CONTENT
%state CHARCLASS, COPY, REPEATEXP, EATWSPNL
%state USEREPILOGUE

%cupdebug

%{  
  internal int balance = 0;
  internal int commentbalance = 0;
  internal int action_line = 0;
  internal int bufferSize = 16384;

  internal File file;
  internal Stack files = new Stack();

  internal StringBuilder userCode   = new StringBuilder();
  internal StringBuilder epilogue   = new StringBuilder();
  internal int epilogue_line = 0;
  private bool epilogue_sent = false;
  
  internal String classCode;
  internal String initCode;   
  internal String initThrow;
  internal String eofCode;
  internal String eofThrow;
  internal String lexThrow;
  internal String eofVal;
  internal String scanErrorException;
  internal String cupSymbol = "sym";

  internal StringBuilder actionText = new StringBuilder();
  internal StringBuilder @string    = new StringBuilder();
  
  internal bool charCount;
  internal bool lineCount;
  internal bool columnCount;
  internal bool cupCompatible;  
  internal bool cupDebug;
  internal bool isInteger;
  internal bool isIntWrap;
  internal bool isYYEOF;
  internal bool notUnix;
  internal bool isPublic;
  internal bool isFinal;
  internal bool isAbstract;
  internal bool lookAheadUsed;
  internal bool bolUsed;
  internal bool standalone;
  internal bool debugOption;
  internal bool useRowMap = Options.gen_method == Options.PACK || Options.gen_method == Options.TABLE;
  internal bool packed = Options.gen_method == Options.PACK;
  internal bool caseless;
  internal bool inclusive_states;
  internal bool eofclose;
    
  internal String isImplementing;
  internal String isExtending;
  internal String className = "Yylex";
  internal String functionName;
  internal String tokenType;
  internal String visibility = "public";
    
  internal LexicalStates states = new LexicalStates();

  internal ArrayList actions = new PrettyArrayList();
  
  private int nextState;

  internal bool macroDefinition;

  internal Timer t = new Timer();

  public int currentLine() {
    return yyline;
  }    

  public void setFile(File file) {
    this.file = file;
  }

  private Symbol symbol(int type, Object value) {
    return new Symbol(type, yyline, yycolumn, value);
  }

  private Symbol symbol(int type) {
    return new Symbol(type, yyline, yycolumn);
  }
   
  // updates line and column count to the beginning of the first
  // non whitespace character in yytext, but leaves yyline+yycolumn 
  // untouched
 
  private Symbol symbol_countUpdate(int type, Object value) {
     int lc = yyline;
     int cc = yycolumn;
     String text = yytext();

     for (int i=0; i < text.Length; i++) {
      char c = text[i];

      if (c != '\n' && c != '\r' && c != ' ' && c != '\t' ) 
        return new Symbol(type, lc, cc, value);

      if (c == '\n') {
        lc++;
        cc = 0;
      }
      else
        cc++;
    }
   
    return new Symbol(type, yyline, yycolumn, value);
  }

  int yyline_copy, yycolumn_copy;

  private void updateCopyOfLineCount(String text) {

    yyline_copy = yyline;
    yycolumn_copy = yycolumn;

    for (int i=0; i < text.Length; i++) {
      char c = text[i];

      if (c == '\n') {
        yyline_copy++;
        yycolumn_copy = 0;
      }
      else
        yycolumn_copy++;
    }

  }

  private String makeMacroIdent() {
    String matched = yytext().Trim();
    return matched.Substring(1, matched.Length-2).Trim();
  }

  public static String conc(Object a, Object b) {
    if (a == null && b == null) return null;
    if (a == null) return b.ToString();
    if (b == null) return a.ToString();
    
    return a.ToString()+b.ToString();
  }

  public static String concExc(Object a, Object b) {
    if (a == null && b == null) return null;
    if (a == null) return b.ToString();
    if (b == null) return a.ToString();
    
    return a.ToString()+", "+b.ToString();
  }
%}

%init{
  states.insert("YYINITIAL", true);
%init}


Digit      = [0-9]
HexDigit   = [0-9a-fA-F]
OctDigit   = [0-7]

Number     = {Digit}+
HexNumber  = \\ x {HexDigit} {2}
Unicode    = \\ u {HexDigit} {1, 4}
OctNumber  = \\ [0-3]? {OctDigit} {1, 2}  

// see http://www.unicode.org/unicode/reports/tr18/
WSP        = [ \t\b]
WSPNL      = [\u2028\u2029\u000A\u000B\u000C\u000D\u0085\t\b\ ]
NL         = [\u2028\u2029\u000A\u000B\u000C\u000D\u0085] | \u000D\u000A
NNL        = [^\u2028\u2029\u000A\u000B\u000C\u000D\u0085]

Ident      = {IdentStart} {IdentPart}*
QualIdent  = {Ident} ( {WSP}* "." {WSP}* {Ident} )*
QUIL       = {QualIdent} ( {WSP}* "," {WSP}* {QualIdent} )*
Array      = "[" {WSP}* "]"
ArrType    = {QualIdent} ({WSP}* {Array})*

IdentStart = [:jletter:]
IdentPart  = [:jletterdigit:]

JFlexCommentChar = [^*/]|"/"+[^*/]|"*"+[^*/]
JFlexComment = {JFlexCommentChar}*

/* Java comments */
JavaComment = {TraditionalComment}|{EndOfLineComment}
TraditionalComment = "/*"{CommentContent}\*+"/"
EndOfLineComment = "//".*{NL}

CommentContent = ([^*]|\*+[^*/])*

StringCharacter = [^\u2028\u2029\u000A\u000B\u000C\u000D\u0085\"\\]

CharLiteral = \'([^\u2028\u2029\u000A\u000B\u000C\u000D\u0085\'\\]|{EscapeSequence})\'
StringLiteral = \"({StringCharacter}|{EscapeSequence})*\"

EscapeSequence = \\[^\u2028\u2029\u000A\u000B\u000C\u000D\u0085]|\\+u{HexDigit}{4}|\\[0-3]?{OctDigit}{1,2}

/* \\(b|t|n|f|r|\"|\'|\\|[0-3]?{OctDigit}{1,2}|u{HexDigit}{4}) */

JavaRest = [^\{\}\"\'/]|"/"[^*/]      
JavaCode = ({JavaRest}|{StringLiteral}|{CharLiteral}|{JavaComment})+

%%

<YYINITIAL> {
  "%%".*{NL}?              { 
                             t.start(); 
                             yybegin(MACROS); 
                             macroDefinition = true; 
                             return symbol(USERCODE, userCode); 
                           }
  .*{NL}                   { userCode.Append(yytext()); }            
  .*                       { return symbol(EOF); }
}

<MACROS>   ("%{"|"%init{"|"%initthrow{"|"%eof{"|"%eofthrow{"|"%yylexthrow{"|"%eofval{").*{NL}
                                     { @string.Length = 0; yybegin(COPY); }
<COPY> {
  "%}".*{NL}                    { classCode = conc(classCode,@string);  yybegin(MACROS);  }
  "%init}".*{NL}                { initCode = conc(initCode,@string);    yybegin(MACROS);  }
  "%initthrow}".*{NL}           { initThrow = concExc(initThrow,@string);  yybegin(MACROS); }
  "%eof}".*{NL}                 { eofCode = conc(eofCode,@string); yybegin(MACROS); }
  "%eofthrow}".*{NL}            { eofThrow = concExc(eofThrow,@string); yybegin(MACROS); }
  "%yylexthrow}".*{NL}          { lexThrow = concExc(lexThrow,@string); yybegin(MACROS); }
  "%eofval}".*{NL}              { eofVal = @string.ToString(); yybegin(MACROS); }

  .*{NL}                        { @string.Append(yytext()); }

  <<EOF>>                       { throw new ScannerException(file,ErrorMessages.EOF_IN_MACROS); }
}


<MACROS> ^"%s" ("tate" "s"?)? {WSP}+   { inclusive_states = true; yybegin(STATELIST); }
<MACROS> ^"%x" ("state" "s"?)? {WSP}+  { inclusive_states = false; yybegin(STATELIST); }
<STATELIST> {
  {Ident}                             { states.insert(yytext(),inclusive_states); }
  ([\ \t]*","[\ \t]*)|([\ \t]+)       { }
  {NL}                                { yybegin(MACROS);  }
  <<EOF>>                       { throw new ScannerException(file,ErrorMessages.EOF_IN_MACROS); }
}

<MACROS> {
  "%char"                     { charCount = true;  }
  "%line"                     { lineCount = true;  }
  "%column"                   { columnCount = true; }
  "%byaccj"                   { isInteger = true;
                                if (eofVal == null)
                                  eofVal = "return 0;";
                                eofclose = true;
                              }
  "%cup"                      { cupCompatible = true;  
                                isImplementing = concExc(isImplementing, "java_cup.runtime.Scanner");
                                if (functionName == null)
                                  functionName = "next_token";
                                if (tokenType == null)
                                  tokenType = "java_cup.runtime.Symbol";
                                if (eofVal == null)
                                  eofVal = "return new java_cup.runtime.Symbol("+cupSymbol+".EOF);";
                                if (!Options.jlex) eofclose = true;
                              }
  "%cupsym"{WSP}+{QualIdent} {WSP}*  { cupSymbol = yytext().Substring(8).Trim(); 
                                if (cupCompatible) Out.warning(ErrorMessages.CUPSYM_AFTER_CUP, yyline); }
  "%cupsym"{WSP}+{NNL}*       { throw new ScannerException(file,ErrorMessages.QUIL_CUPSYM, yyline); }
  "%cupdebug"                 { cupDebug = true; }
  "%eofclose"({WSP}+"true")?  { eofclose = true; }
  "%eofclose"({WSP}+"false")  { eofclose = false; }
  "%class"{WSP}+{Ident} {WSP}*      { className = yytext().Substring(7).Trim();  }
  "%function"{WSP}+{Ident} {WSP}*   { functionName = yytext().Substring(10).Trim(); }
  "%type"{WSP}+{ArrType} {WSP}*     { tokenType = yytext().Substring(6).Trim(); }
  "%integer"|"%int"           { isInteger = true;  }
  "%intwrap"                  { isIntWrap = true;  }
  "%yyeof"                    { isYYEOF = true;  }
  "%notunix"                  { notUnix = true;  }
  "%7bit"                     {  }
  "%full"|"%8bit"             { return symbol(FULL); }
  "%unicode"|"%16bit"         { return symbol(UNICODE);  }
  "%caseless"|"%ignorecase"   { caseless = true; }
  "%implements"{WSP}+.*       { isImplementing = concExc(isImplementing, yytext().Substring(12).Trim());  }
  "%extends"{WSP}+{QualIdent}{WSP}* { isExtending = yytext().Substring(9).Trim(); }
  "%public"                   { isPublic = true; }
  "%apiprivate"               { visibility = "private"; Skeleton.makePrivate(); }
  "%final"                    { isFinal = true; }
  "%abstract"                 { isAbstract = true; }
  "%debug"                    { debugOption = true; }
  "%standalone"               { standalone = true; isInteger = true; }
  "%switch"                   { packed = false; useRowMap = false; }
  "%table"                    { packed = false; useRowMap = true; }
  "%pack"                     { packed = true; useRowMap = true; }
  "%include" {WSP}+ .*        { File f = new File(yytext().Substring(9).Trim());
                                if ( !f.canRead() )
                                  throw new ScannerException(file,ErrorMessages.NOT_READABLE, yyline); 
                                // check for cycle
                                // FIXME: this is an extremely ugly hack for the C# version
                                if (new ArrayList(files.ToArray()).Contains(f))
                                  throw new ScannerException(file,ErrorMessages.FILE_CYCLE, yyline);
                                try {
                                  yypushStream( new StreamReader(f) );
                                  files.Push(file);
                                  file = f;
                                  Out.println("Including \""+file+"\"");
                                }
                                catch (FileNotFoundException) {
                                  throw new ScannerException(file,ErrorMessages.NOT_READABLE, yyline); 
                                } 
                              }
  "%buffer" {WSP}+ {Number} {WSP}*   { bufferSize = Integer.parseInt(yytext().Substring(8).Trim()); }
  "%buffer" {WSP}+ {NNL}*     { throw new ScannerException(file,ErrorMessages.NO_BUFFER_SIZE, yyline); }
  "%initthrow" {WSP}+ {QUIL} {WSP}* { initThrow = concExc(initThrow,yytext().Substring(11).Trim()); }
  "%initthrow" {WSP}+ {NNL}*  { throw new ScannerException(file,ErrorMessages.QUIL_INITTHROW, yyline); }
  "%eofthrow"  {WSP}+ {QUIL} {WSP}*  { eofThrow = concExc(eofThrow,yytext().Substring(10).Trim()); }
  "%eofthrow"  {WSP}+ {NNL}*  { throw new ScannerException(file,ErrorMessages.QUIL_EOFTHROW, yyline); }
  "%yylexthrow"{WSP}+ {QUIL} {WSP}*  { lexThrow = concExc(lexThrow,yytext().Substring(12).Trim()); }
  "%throws"    {WSP}+ {QUIL} {WSP}*  { lexThrow = concExc(lexThrow,yytext().Substring(8).Trim()); }
  "%yylexthrow"{WSP}+ {NNL}*  { throw new ScannerException(file,ErrorMessages.QUIL_YYLEXTHROW, yyline); }
  "%throws"    {WSP}+ {NNL}*  { throw new ScannerException(file,ErrorMessages.QUIL_THROW, yyline); }
  "%scanerror" {WSP}+ {QualIdent} {WSP}* { scanErrorException = yytext().Substring(11).Trim(); }
  "%scanerror" {WSP}+ {NNL}*  { throw new ScannerException(file,ErrorMessages.QUIL_SCANERROR, yyline); }

  {Ident}                     { return symbol(IDENT, yytext()); }
  "="{WSP}*                   { yybegin(REGEXP); return symbol(EQUALS); }

  "/*"                        { nextState = MACROS; yybegin(COMMENT); }
  
  {EndOfLineComment}          { }

  /* no {NL} at the end of this expression, because <REGEXPSTART> 
     needs at least one {WSPNL} to start a regular expression! */   
  ^"%%" {NNL}*                { macroDefinition = false; yybegin(REGEXPSTART); return symbol(DELIMITER); }
  "%"{Ident}                  { throw new ScannerException(file,ErrorMessages.UNKNOWN_OPTION, yyline, yycolumn); }
  "%"                         { throw new ScannerException(file,ErrorMessages.UNKNOWN_OPTION, yyline, yycolumn); }
  ^{WSP}+"%"                  { Out.warning(ErrorMessages.NOT_AT_BOL, yyline); yypushback(1); }

  {WSP}+                      { }
  {NL}+                       { }                        
  <<EOF>>                     { if ( yymoreStreams() ) {
                                  file = (File) files.Pop();
                                  yypopStream();
                                }
                                else
                                  throw new ScannerException(file,ErrorMessages.EOF_IN_MACROS); 
                              }
}

<REGEXPSTART> {
  {WSPNL}* "/*"               { nextState = REGEXPSTART; yybegin(COMMENT); }
  {WSPNL}+                    { yybegin(REGEXP); }
  {WSPNL}* "<"                { yybegin(STATES); return symbol_countUpdate(LESSTHAN, null); }
  {WSPNL}* "}"                { return symbol_countUpdate(RBRACE, null); }
  {WSPNL}* "//" {NNL}*        { }  
  {WSPNL}* "<<EOF>>" {WSPNL}* "{" 
                              { actionText.Length = 0; yybegin(JAVA_CODE);
                                updateCopyOfLineCount(yytext());
                                action_line = yyline_copy + 1;
                                actionText.Append(new string(' ', yycolumn_copy));
                                return symbol_countUpdate(EOFRULE, null); }
  {WSPNL}*{NL}+ "%%".*{NL}    { yybegin(USEREPILOGUE);
                                epilogue.Length = 0;
                                updateCopyOfLineCount(yytext());
                                epilogue_line = yyline_copy + 1;
                                return symbol(DELIMITER); }
}

<STATES> {
  {Ident}                     { return symbol(IDENT, yytext()); }
  ","                         { return symbol(COMMA); }
  {WSPNL}+                    { }

  // "{" will be caught in REGEXP  
  ">"{WSPNL}*                 { yybegin(REGEXP); return symbol(MORETHAN); }

  <<EOF>>                     { throw new ScannerException(file,ErrorMessages.EOF_IN_STATES); }
}


<REGEXP> {
  "<<EOF>>" {WSPNL}+ "{"  { actionText.Length = 0; yybegin(JAVA_CODE);
                            updateCopyOfLineCount(yytext());
                            action_line = yyline_copy + 1;
                            actionText.Append(new string(' ', yycolumn_copy));
                            return symbol(EOFRULE); }
  "<<EOF>>"               { throw new ScannerException(file,ErrorMessages.EOF_WO_ACTION); }

  {WSPNL}*"|"{WSP}*$      { if (macroDefinition) {
                              yybegin(EATWSPNL);
                              return symbol(BAR); 
                            }
                            else { 
                              yybegin(REGEXPSTART); 
                              return symbol(NOACTION); 
                            }
                          }

  // stategroup
  "{"          { yybegin(REGEXPSTART); return symbol(LBRACE); }

  {WSPNL}*"|"  { return symbol(BAR); }

  {WSPNL}*\"   { @string.Length = 0; nextState = REGEXP; yybegin(STRING_CONTENT); }
  {WSPNL}*"!"  { return symbol(BANG); }
  {WSPNL}*"~"  { return symbol(TILDE); }
  {WSPNL}*"("  { return symbol(OPENBRACKET); }
  {WSPNL}*")"  { return symbol(CLOSEBRACKET); }
  {WSPNL}*"*"  { return symbol(STAR); }
  {WSPNL}*"+"  { return symbol(PLUS); }
  {WSPNL}*"?"  { return symbol(QUESTION); }
  {WSPNL}*"$"  { lookAheadUsed = true; return symbol(DOLLAR); }
  {WSPNL}*"^"  { bolUsed = true; return symbol(HAT); }
  {WSPNL}*"."  { return symbol(POINT); }
  {WSPNL}*"["  { yybegin(CHARCLASS); return symbol(OPENCLASS); }
  {WSPNL}*"/"  { lookAheadUsed = true; return symbol(LOOKAHEAD); }
  
  {WSPNL}* "{" {WSP}* {Ident} {WSP}* "}" { return symbol_countUpdate(MACROUSE, makeMacroIdent()); }
  {WSPNL}* "{" {WSP}* {Number}   { yybegin(REPEATEXP); return symbol(REPEAT, int.Parse(yytext().Trim().Substring(1).Trim())); }

  {WSPNL}+ "{"    { actionText.Length = 0; yybegin(JAVA_CODE);
                    updateCopyOfLineCount(yytext());
                    action_line = yyline_copy + 1;
                    actionText.Append(new string(' ', yycolumn_copy));
                    return symbol(REGEXPEND); }
  {NL}            { if (macroDefinition) { yybegin(MACROS); } return symbol(REGEXPEND); }

  {WSPNL}*"/*"    { nextState = REGEXP; yybegin(COMMENT); }

  {WSPNL}*"//"{NNL}*  { }

  {WSP}+          { }

  <CHARCLASS> {
    {WSPNL}*"[:jletter:]"  { return symbol(JLETTERCLASS); }
    {WSPNL}*"[:jletterdigit:]" { return symbol(JLETTERDIGITCLASS); }
    {WSPNL}*"[:letter:]"     { return symbol(LETTERCLASS); }
    {WSPNL}*"[:digit:]"      { return symbol(DIGITCLASS); }
    {WSPNL}*"[:uppercase:]"  { return symbol(UPPERCLASS); }
    {WSPNL}*"[:lowercase:]"  { return symbol(LOWERCLASS); }
  }

  . { return symbol(CHAR, yytext()[0]); }
}

<EATWSPNL> {WSPNL}+  { yybegin(REGEXP); }


<REPEATEXP> {
  "}"          { yybegin(REGEXP); return symbol(RBRACE); }
  "," {WSP}* {Number}  { return symbol(REPEAT, int.Parse(yytext().Substring(1).Trim())); }
  {WSP}+       { }

  <<EOF>>                 { throw new ScannerException(file,ErrorMessages.EOF_IN_REGEXP); }
}

<CHARCLASS> {
  "{"{Ident}"}" { return symbol(MACROUSE, yytext().Substring(1,yytext().Length-2)); }
  "["  { balance++; return symbol(OPENCLASS); }
  "]"  { if (balance > 0) balance--; else yybegin(REGEXP); return symbol(CLOSECLASS); }
  "^"  { return symbol(HAT); }
  "-"  { return symbol(DASH); }

  // this is a hack to keep JLex compatibilty with char class 
  // expressions like [+-]
  "-]" { yypushback(1); yycolumn--; return symbol(CHAR, yytext()[0]); }  

  \"   { @string.Length = 0; nextState = CHARCLASS; yybegin(STRING_CONTENT); }

  .    { return symbol(CHAR, yytext()[0]); }

  \n   { throw new ScannerException(file,ErrorMessages.EOL_IN_CHARCLASS,yyline,yycolumn); }

  <<EOF>>     { throw new ScannerException(file,ErrorMessages.EOF_IN_REGEXP); }
}

<STRING_CONTENT> {
  \"       { yybegin(nextState); return symbol(STRING, @string.ToString()); }
  \\\"     { @string.Append('\"'); }
  [^\"\\\u2028\u2029\u000A\u000B\u000C\u000D\u0085]+ { @string.Append(yytext()); }

  {NL}     { throw new ScannerException(file,ErrorMessages.UNTERMINATED_STR, yyline, yycolumn); }

  {HexNumber} { @string.Append( (char) Integer.parseInt(yytext().Substring(2,yytext().Length-2), 16)); }
  {Unicode}   { @string.Append( (char) Integer.parseInt(yytext().Substring(2,yytext().Length-2), 16)); }
  {OctNumber} { @string.Append( (char) Integer.parseInt(yytext().Substring(1,yytext().Length-1), 8)); }

  \\b { @string.Append('\b'); }
  \\n { @string.Append('\n'); }
  \\t { @string.Append('\t'); }
  \\f { @string.Append('\f'); }
  \\r { @string.Append('\r'); }

  \\. { @string.Append(yytext()[1]); }

  <<EOF>>     { throw new ScannerException(file,ErrorMessages.EOF_IN_STRING); }
}


<REGEXP, CHARCLASS> {
  {HexNumber} { return symbol(CHAR, (char) Integer.parseInt(yytext().Substring(2,yytext().Length-2), 16)); }
  {Unicode} { return symbol(CHAR, (char) Integer.parseInt(yytext().Substring(2,yytext().Length-2), 16)); }
  {OctNumber} { return symbol(CHAR, (char) Integer.parseInt(yytext().Substring(1,yytext().Length-1), 8)); }

  \\b { return symbol(CHAR, '\b'); }
  \\n { return symbol(CHAR, '\n'); }
  \\t { return symbol(CHAR, '\t'); }
  \\f { return symbol(CHAR, '\f'); }
  \\r { return symbol(CHAR, '\r'); }

  \\. { return symbol(CHAR, yytext()[1]); }
}


<USEREPILOGUE> {
  .*{NL}                   { epilogue.Append(yytext()); }            
  .*                       { epilogue.Append(yytext()); }
  <<EOF>>                  { if ( yymoreStreams() )
                             {
                               file = (File) files.Pop();
                               yypopStream();
                             }
                             else if (epilogue_sent)
                               return symbol(EOF);
                             else
                             {
                               epilogue_sent = true;
                               return symbol(EPILOGUE, epilogue);
                             }
                           }
}

<JAVA_CODE> {
  "{"        { balance++; actionText.Append('{'); }
  "}"        { if (balance > 0) {
                 balance--;     
                 actionText.Append('}'); 
               }
               else {
                 yybegin(REGEXPSTART); 
                 Action a = new Action(actionText.ToString(), action_line);
                 actions.Add(a);
                 return symbol(ACTION, a);
               }
             } 
           
  {JavaCode}     { actionText.Append(yytext()); } 

  <<EOF>>     { throw new ScannerException(file,ErrorMessages.EOF_IN_ACTION, action_line-1); }
}

<COMMENT> {
   
  "/"+ "*"  { commentbalance++; }
  "*"+ "/"  { if (commentbalance > 0) 
                commentbalance--; 
              else
                yybegin(nextState); 
            }
  
  {JFlexComment} { /* ignore */ }

  <<EOF>>     { throw new ScannerException(file,ErrorMessages.EOF_IN_COMMENT); }
}

.  { throw new ScannerException(file,ErrorMessages.UNEXPECTED_CHAR, yyline, yycolumn); }
\n { throw new ScannerException(file,ErrorMessages.UNEXPECTED_NL, yyline, yycolumn); }

<<EOF>>  { if ( yymoreStreams() ) {
             file = (File) files.Pop();
             yypopStream();
           }
           else 
             return symbol(EOF); }

%%

} // end of 'namespace'
